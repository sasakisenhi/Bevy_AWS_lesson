# game_logic Instructions

本ドキュメントは、`game_logic` クレートにおける  
**実装上の指針と責務の境界**を定義する。

本クレートは、`copilot-instructions.md`、`architecture.md`、  
および `game_core.instructions.md` を前提とする。

---

## game_logic の目的

`game_logic` は、  
`game_core` に定義された概念・ルールを用いて、  
**ゲームとして意味のある振る舞いを構成する層**である。

- ゲームルールの組み立て
- 状態更新の流れの定義
- 複数ルールの相互作用の制御
- ゲーム進行の管理
- ロジックに関するユーティリティ機能の提供

を主な責務とする。

---

## 許可される依存関係

- `game_core`
- Rust 標準ライブラリ
- ロジック構築を補助する小規模なユーティリティクレート
- テスト専用クレート（`#[cfg(test)]` 下）

---

## 禁止・制限される依存関係

以下への直接依存は禁止、または強く制限する。

- Bevy の Plugin / App / Window / Renderer への直接依存
- 入力デバイス・描画・UI への直接依存
- OS やプラットフォーム固有機能
- グローバル状態・シングルトン的構造
- 乱数の直接使用  
（必要な場合は、外部から注入された値を用いる）

これらは **`game_runtime` の責務**である。

---

## 実装スタイルの指針

- `game_logic` は **「何が起きるか」** を定義し、
  **「どう表示されるか」** は定義しない
- ロジックは、可能な限り
  - 明示的な入力
  - 明示的な出力
  を持つ形で表現する
- ECS に依存しない形で書けるロジックは、
  可能な限りその形を保つ
- 状態管理は最小限に留める
- 所有権・借用ルールを尊重する
- ECS を前提とした設計は許容するが、
  Bevy 固有の型・API への直接依存は避ける

---

## core / runtime との境界判断

次の基準で置き場所を判断する。

- 「概念・ルールそのものか？」  
  → **game_core**
- 「ルールをどう組み合わせ、進行させるか？」  
  → **game_logic**
- 「入力・描画・時間とどう接続するか？」  
  → **game_runtime**

迷った場合は、  
一段下の層（より抽象的な層）に置けないかを検討する。

---

## テストについて

- `game_logic` のロジックは、可能な限り単体テスト可能にする
- 複数ルールの相互作用は、代表的ケースをテストで固定する
- 乱数・時間に依存する処理は、
  外部から注入できる形を優先する
- `cargo test` が常に成功する状態を保つ

---

## 迷ったときの判断基準

次の問いに YES と答えられない場合、  
その実装は `game_logic` に置くべきではない可能性がある。

- 「これは game_core の概念を“使っている”か？」
- 「描画や入力がなくても意味を持つか？」
- 「runtime に寄せた方が自然ではないか？」
