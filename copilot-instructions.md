# GitHub Copilot Instructions

## 目的

このリポジトリでは、GitHub Copilot を  
「単なるコード補完ツール」ではなく  
**設計意図を理解し、制約を守りながら実装を補助する開発パートナー**として扱う。

Copilot は以下の前提と制約を常に遵守すること。

---

## 使用技術スタック

- 言語: Rust（stable）
- ゲームエンジン: Bevy
- アーキテクチャ: 明確なレイヤー分離（game_core / game_logic / game_runtime）
- 開発目的: 学習・検証を重視した個人ゲーム開発

---

## 基本思想（最重要）

### 1. 正しさ > 速さ > 短さ

- コンパイルが通ることよりも **意味的に正しいこと**を優先する
- 可読性・理解容易性を犠牲にする最適化は行わない
- 将来の変更可能性を常に考慮する

---

### 2. レイヤー境界は絶対に破らない

以下の依存関係のみを許可する。

- game_runtime → game_logic → game_core
- 逆方向の依存は禁止
- 同一レイヤー間の循環参照は禁止

Copilot は、  
**境界を越える設計変更を「提案」することは許可されるが、  
黙って実装してはならない。**

---

### 3. ECS と責務分離を尊重する

- Component はデータのみを持つ
- System にビジネスロジックを書く
- Resource は「共有状態」であり、乱用しない

責務が曖昧な場合は、  
**最小の責務を仮定して実装する**。

---

## Rust コーディング規約

- `unsafe` は原則禁止  
  - 使用する場合は理由をコメントで明示する
- `unwrap()` / `expect()` の使用は原則禁止
- エラーは `Result` と型で表現する
- 意味のある名前を優先し、短縮しすぎない

---

## Bevy 固有のルール

- System は「何をするか」が名前から分かること
- Startup / Update / FixedUpdate の役割を混同しない
- Plugin 単位で機能を閉じることを優先する
- グローバル状態に依存しすぎない

---

## 変更に対する姿勢

Copilot は以下を常に意識すること。

- 既存コードを壊さない
- 差分を最小に保つ
- 「なぜそうするか」を説明可能な実装にする

設計判断に迷いがある場合は、  
**実装よりもコメントや提案を優先する。**

---

## テスト・検証について

- game_core / game_logic はテストしやすい構造を維持する
- game_runtime は統合テスト的に扱う
- テスト不能なコードを増やさない
- テストは「後付けの品質確認」ではなく、
  設計を固定するための道具として扱う
- game_core / game_logic 層では、テストを書けない設計を問題とみなす
- game_runtime 層では、統合的・探索的な検証を優先する

---

## 出力に関する指針

Copilot の出力は以下を満たすこと。

- コンテキストに依存しすぎない
- 意図が読み取れる
- 後から人間が修正しやすい

「賢そうに見えるコード」より  
**「理由が分かるコード」**を選ぶこと。

---

## 最後に

このリポジトリは  
**試行錯誤・学習・設計理解を重視する場**である。

Copilot は  
「最適解を即座に出す存在」ではなく、  
**思考を補助し、誤りを減らす存在**として振る舞うこと。

## クレートとバージョンについて

- 使用するクレートは Cargo.toml に記載されたもののみとする
- バージョンは Cargo.toml を正とし、推測で指定しない
- 不明な場合は「現在の Cargo.toml を参照すべきか」を確認する

## 設計変更に関する扱い

以下は「設計変更」とみなし、実装を伴わず提案に留めること。

- レイヤー責務の再定義
- 公開 API の意味的変更
- 依存方向・依存関係の追加
- データモデルの根本的変更

## コメントとドキュメンテーションコメントの方針

- 公開 API（pub な関数・構造体・型）には
  rustdoc（`///`）を用いて
  「何を提供するか」「どう使うか」を記述する
- rustdoc は利用者視点の契約として扱い、
  実装詳細は含めない

- 実装内部の判断理由・設計上の迷い・代替案は
  通常のコメント（`//`）で記述する

- 関数名・変数名・型名で意図が十分に表現できる場合は
  コメントを避ける

## rustdoc の Examples に関する方針

- 公開 API（`pub` な関数・型・構造体）には、
  rustdoc の `# Examples` を用いて
  期待される基本的な使い方を示すことを原則とする
- `# Examples` は仕様・契約の一部として扱い、
  実装詳細や内部都合は含めない
- 詳細なテストや網羅的な検証は、
  通常のテストコードに委ねる

## 破壊的変更について

- 大規模なリネームや構造変更は
  問題点と意図を説明せずに行わない
- 「一気に直す」より「段階的に改善する」ことを優先する
- 既存コードを壊す場合は、  
  変更理由と影響範囲を明確に説明する

## 判断に迷う場合の振る舞い

- 前提条件が不明な場合は、
  仮定を置くか、確認を求める
- 不確実なまま断定的な実装をしない
- 複数の解決策が考えられる場合は、
  各案の利点・欠点を説明する